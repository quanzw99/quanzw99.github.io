<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Paper Reading 1 - Intersection Prediction for Accelerated GPU Ray Tracing | Quanzw's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=G-PH7R3FX4D4" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-PH7R3FX4D4');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Paper Reading 1 - Intersection Prediction for Accelerated GPU Ray Tracing</h1><a id="logo" href="/.">Quanzw's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/tags/"><i class="fa fa-tag"> tag</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Paper Reading 1 - Intersection Prediction for Accelerated GPU Ray Tracing</h1><div class="post-meta">2023-07-24<span> | </span><span class="category"><a href="/categories/Reading/">Reading</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BACKGROUND-amp-MOTIVATION"><span class="toc-number">2.</span> <span class="toc-text">BACKGROUND &amp; MOTIVATION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU-Architecture"><span class="toc-number">2.1.</span> <span class="toc-text">GPU Architecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ray-Tracing"><span class="toc-number">2.2.</span> <span class="toc-text">Ray Tracing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ambient-Occlusion"><span class="toc-number">2.3.</span> <span class="toc-text">Ambient Occlusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ray-Traversal-Algorithm"><span class="toc-number">2.4.</span> <span class="toc-text">Ray Traversal Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accelerating-Ray-Tracing"><span class="toc-number">2.5.</span> <span class="toc-text">Accelerating Ray Tracing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAY-INTERSRCTION-PREDICTOR-ALGORITHM"><span class="toc-number">3.</span> <span class="toc-text">RAY INTERSRCTION PREDICTOR ALGORITHM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PROPOSED-ARCHITECTURE"><span class="toc-number">4.</span> <span class="toc-text">PROPOSED ARCHITECTURE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Predictor-Table-Architecture"><span class="toc-number">4.1.</span> <span class="toc-text">Predictor Table Architecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashing"><span class="toc-number">4.2.</span> <span class="toc-text">Hashing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-Up-Level"><span class="toc-number">4.3.</span> <span class="toc-text">Go Up Level</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Warp-Repacking"><span class="toc-number">4.4.</span> <span class="toc-text">Warp Repacking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardware-Implementation"><span class="toc-number">4.5.</span> <span class="toc-text">Hardware Implementation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#METHODOLOGY"><span class="toc-number">5.</span> <span class="toc-text">METHODOLOGY</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ray-Tracing-Unit"><span class="toc-number">5.1.</span> <span class="toc-text">Ray Tracing Unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simulation"><span class="toc-number">5.2.</span> <span class="toc-text">Simulation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESULTS"><span class="toc-number">6.</span> <span class="toc-text">RESULTS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Predictor-Table-Configuration"><span class="toc-number">6.1.</span> <span class="toc-text">Predictor Table Configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-Predictor-Configurations"><span class="toc-number">6.2.</span> <span class="toc-text">Other Predictor Configurations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Limit-Study"><span class="toc-number">6.3.</span> <span class="toc-text">Limit Study</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-Applications"><span class="toc-number">6.4.</span> <span class="toc-text">Other Applications</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RELATED-WORKS"><span class="toc-number">7.</span> <span class="toc-text">RELATED WORKS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CONCLUSION"><span class="toc-number">8.</span> <span class="toc-text">CONCLUSION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUESTIONS"><span class="toc-number">9.</span> <span class="toc-text">QUESTIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REFERENCES"><span class="toc-number">10.</span> <span class="toc-text">REFERENCES</span></a></li></ol></div></div><div class="post-content"><p>Tor Aamodt在<a target="_blank" rel="noopener" href="https://people.ece.ubc.ca/~aamodt/projects/graphics/">个人主页</a>中描述了研究<code>Graphics Hardware</code>的动机。此外，在<a target="_blank" rel="noopener" href="https://people.ece.ubc.ca/~aamodt/publications/">Publication页面</a>分享了<a target="_blank" rel="noopener" href="https://people.ece.ubc.ca/~aamodt/publications/papers/liu.micro2021.pdf">本文</a>的<a target="_blank" rel="noopener" href="https://github.com/ubc-aamodt-group/ray-intersection-predictor">code</a>和<a target="_blank" rel="noopener" href="http://www.lufei.ca/files/MicroVideo.mp4">video</a>。<span id="more"></span></p>
<p><strong><em>ABSTRACT</em></strong></p>
<p>多年来，<code>ray tracing</code>被用于制作逼真的电影图像，而更快的<code>raster-based</code>基于光栅化的着色技术一直是视频游戏的优先选择，以满足实时需求。然而，最近的<code>GPUs</code>集成了为光追设计的硬件加速器单元。这些加速器单元针对遍历层次化树状数据结构的过程，这种树状结构用于测试<code>ray-object intersection</code>光线和物体是否相交。在这种数据结构中，朝着相似路径的不同光线会执行很多冗余的<code>ray-box intersection</code>光-盒相交测试。我们提出了一种<code>ray intersection predictor</code>光线相交预测器，在此过程中可以推测性地省略冗余操作，并直接测试光线可能相交的原始物体。我们的<code>predictor</code>的一个关键点是包含了<code>identifying hash function</code>识别哈希函数，这些函数能够保留足够的空间信息，以识别冗余的遍历操作。我们将探讨如何将光线预测策略集成到现有的<code>GPU</code>管线上，并通过预测树上更高层次的节点（靠近根节点的节点）以及更低成本的更谨慎的方式重新组合和调度遍历操作，来提高<code>predictor</code>的效率。在搭载光追加速器单元的移动类<code>GPU</code>上，每个<code>streaming multiprocessor</code>流处理器增加一个5.5KB的预测器后，对于<code>ambient occlusion</code>环境光遮蔽工作负载，<code>geometric mean</code>几何平均提高了26%。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>实时光追有望改变视频游戏的格局。拥有硬件加速的光追功能的<code>GPU</code>使开发者能在计算预算内实现更令人信服的视觉效果。光追通过物理准确的渲染算法产生逼真的图像。常见的<code>Whitted-style</code>光追将光模拟为从相机发出并与环境进行交互的光线。这些光线穿过场景，并在与物体和光源相交时积累颜色。因此，<u>光追了可以呈现出光栅化无法实现的视觉效果。</u>例如，光栅化会忽略相机中不可见的物体，因此无法跟踪被忽略对象的间接照明效果。</p>
<p><strong>光追具有丰富的<code>parallelism</code>并行性<sup>1</sup></strong>，非常适合<code>Single Instruction Multiple Data</code><strong>单指令多数据<sup>2</sup></strong>（SIMD）执行。现代光追使用<code>acceleration structures</code>加速结构(AS)，例如<code>the Bounding Volume Hierarchy</code><strong>包围体层次结构<sup>3</sup></strong>（BVM），来组织场景数据以提高搜索光线相交的效率。对于每条光线，都必须执行<code>AS</code>遍历，而光线在场景中的随机散射会导致光线的相交点变得不一致，即相交的物体可能相距较远。因此，简单的光追实现在<code>power</code>功耗和<code>memory utilization</code>内存利用方面效率都不高。例如，不一致的光线会导致计算开销和内存分散，尤其是在<code>SIMD</code>架构中。这些不一致还会对内存层次结构造成压力，<strong>争夺内存带宽<sup>4</sup></strong>并导致<strong>缓存缓冲<sup>5</sup></strong>。然而，就是不一致的光线产生了最令人印象深刻的视觉效果，从而在视觉质量和计算负载之间产生竞争。</p>
<p><code>Ambient Occlusion</code>环境光遮挡（AO）是其中一个受益于光追加速的效果。<code>AO rays</code>AO光线也被称为<code>occlusion rays</code><strong>遮挡光线<sup>6</sup></strong>，用于测试是否与任何物体相交，而不需要找到最近的相交点。遮挡光线很常见且对性能至关重要。这在现代光追API中支持跳过最近最近命中着色器执行功能中得到证明。基础渲染可以通过光栅化高效执行，然后通过光追来增强以保持实时性能。许多商业游戏都通过光追拓展现有的光栅化方法；硬件也应该模拟这种组合。</p>
<p><img src="Figure1.png" alt=""></p>
<p><code>AO</code>的工作负载具有高计算需求，因为每个交代呢都必须使用多条光线进行采样。此外，<code>AO</code>光线通常很短并且在他们访问的<code>AS</code>中存在显著的冗余。<code>Figure 1</code>展示了在<code>AO</code>的工作负载中，对于每个单独的光线，内存访问类型的分布情况，且这个分布是在七个场景下求平均得到的。<code>Figure 1(left)</code>中<code>Repeated BVM Node Accesses</code>占比88%。由于他们不参与最终光线的相交计算，因此有机会通过预测遍历并跳过他们来提高性能。简单地使用缓存来加速计算是不够的，为了实现类似<code>Figure 1(right)</code>看到的相似的加速效果，需要一个非常大的缓存结构，因为<code>AO</code>计算所需的<code>working set</code>很大。</p>
<p>之前的研究通过专用的硬件加速器来加速光追中的<code>AS</code>遍历和光线相交测试。然而这些加速器都是作为独立的加速器设计的，他们与<code>GPU</code>互相孤立。另一个研究领域探索了通过减少光线不一致或者创造更适合<code>GPU</code>的<code>SIMD</code>特性的<code>optimized AS</code>来高效利用<code>GPU</code>硬件的方法。然而，目前的光追性能仍不足以实现3A游戏的实时渲染。</p>
<p>我们提出了一种光线相交预测器，已利用遮挡光线遍历时的冗余和提高内存层次结构的利用。与以前在光栅图形学中帧间缓存不同，我们的预测器专注于当前帧中的冗余。我们利用了<code>AO</code>的特性，他们只在意是否相交而非最近的相交。预测器使用之前相似光线的<code>AS</code>遍历结果来进行预测，通过哈希来确定相似光线。成功的预测可能会直接找到叶子节点、跳过整个遍历过程。错误的预测可能会从根节点从更新开始。在预测后，我们提出的预测器对当前正在遍历<code>AS</code>的<strong><code>warps</code><sup>7</sup></strong>线程束进行重新打包，以提高<strong><code>SIMT</code><sup>8</sup></strong>的效率。</p>
<p><img src="Figure2.png" alt=""></p>
<p><code>Figure 2</code>展示了限制性研究的结果，评估了光线预测的潜力（详见6.3节）。结果显示，使用一个容量为5.5KB的预测器，可以预测38%的光线，这个预测器被理想化为只能执行<code>oracle lookups</code>神谕式的查找，即始终能够识别光线与表中条目的交点，如果这个交点存在的话（Potential Prediction(5.5KB)）。相比之下，我们提出的可实现的5.5KB的光线预测器（详见第4节）实现了26%的加速并且能够识别27%的光线相交(Proposed Predictor)。</p>
<p>为了评估我们的预测器，我们建立了一个基准的光追单元，用于加速在现代<code>GPU</code>中进行的光追，类似于<code>NVIDIA RT Core</code>。我们展示了我们的光追单元在独立运行时的周期级模拟结果与<code>NVIDIA RT Core</code>的性能之间的相关性。建模带有光追单元的<code>GPU</code>可以支持实现光栅化和光追的实际工作负载。我们的模拟器可以在<code>github</code>上获得，地址为<a target="_blank" rel="noopener" href="https://github.com/ubc-aamodt-group/ray-intersection-predictor">https://github.com/ubc-aamodt-group/ray-intersection-predictor</a> 。</p>
<p>本文贡献如下：</p>
<ul>
<li>我们提出并评估了<code>a ray intersection predictor module</code>，它在<code>BVH</code>树遍历的过程中，预测性的跳过了一些<code>ray-box intersection</code>，直接访问<code>AS</code>中深层的节点。</li>
<li>我们在预测器中引入了<code>warp</code>线程束重新打包的拓展，目标是使得线程束内部的线程有类似的工作分配，即在执行完成时的工作量相似，并创建内存访问合并的机会。</li>
<li>我们在周期级<code>GPU</code>模拟器<code>GPGPU-sim</code>中建模了详细的基准光追单元，并于<code>NVIDIA RTX 2080Ti</code>进行了相关性分析。</li>
</ul>
<p>第2节介绍了光追的相关背景信息。第3、4节描述了我们提出的光线相交预测器。第5节详细介绍了我们的方法，包括基准光追单元的描述，随后在第6节给出实验结果，在第7节介绍了相关工作。</p>
<p><strong><em>Notes:</em></strong></p>
<ol>
<li>“光追具有丰富的并行性”是因为在光追算法中，每条光线的计算是互相独立的，没有依赖关系，这意味着可以同时处理多条光线。</li>
<li>“单指令多数据”是一种并行计算模型，它是指一条指令同时作用于多个数据元素。在这种模型中，多个处理单元同时执行相同的指令，但每个处理单元的数据可以是不同的。</li>
<li>“包围体层次结构”是一种树状结构，以提高光线和物体相交计算的效率。思路是将场景中的物体组织成了一系列的层次结构。具体来说，它采用了分治的想法，将场景递归地划分为了一系列<code>Bounding Volume</code>包围体，每个包围体是一个<code>Bounding Box</code>边界盒，它包含了场景中的若干物体。我们可以先测试光线是否与包围体是否相交：如果不相交，就跳过这个包围体内部所有的物体，从而节省了计算时间；如果相交，就进入这个包围体的子包围体重复以上步骤。</li>
<li>“争夺内存带宽”：内存带宽是指计算机系统在单个时间点能从内存读取或者写入数据的能力，当多个光线同时请求读取或者写入数据时，会产生竞争，降低内存访问效率。</li>
<li>“缓存缓冲”：缓存是位于CPU和主内存之间的高速存储器，用于加速数据的访问。当不一致的光线访问的数据不在缓存中时，将频繁地将数据加载到缓存中，从而导致缓存缓冲。</li>
<li>“遮挡光线”：这种光线并不关心找到最近的交点，而是测试光线是否与任何物体相交。它们用于确定场景中的阴影强度，即在某个点周围的环境中，有多少光线被遮挡，从而影响该点的明暗程度。</li>
<li>“warps”: 线程束是一组并行执行的线程。在<code>GPU</code>中，线程被组织成一组线程束，并且这些线程在同一时间周期内执行相同的指令。</li>
<li>“SIMT”: Single Instruction, Multiple Threads. 是一种并行计算模型。在这种模型中多个线程执行相同的指令，但是可能处理不同的数据。</li>
</ol>
<h2 id="BACKGROUND-amp-MOTIVATION"><a href="#BACKGROUND-amp-MOTIVATION" class="headerlink" title="BACKGROUND & MOTIVATION"></a>BACKGROUND &amp; MOTIVATION</h2><p>本节概述了<code>GPU</code>架构和光追。我们通过描述<code>ray traced ambient occlusion</code>光追环境光遮挡面临的挑战来阐述我们研究预测器的动机。</p>
<h3 id="GPU-Architecture"><a href="#GPU-Architecture" class="headerlink" title="GPU Architecture"></a>GPU Architecture</h3><p><img src="Figure3.png" alt=""></p>
<p><code>GPU</code>是由许多<code>streaming multiprocessors</code>流式多处理器（SMs）组成的大规模并行处理器。<code>Figure 3</code>显示多个<code>warps</code>线程束可以在一个单独的<code>SM</code>上执行。每个线程束由32个线程组成，这些线程以<code>lockstep</code>锁步或者<code>SIMT</code>单指令多线程的方式执行。<code>Warp schedulers</code>线程束调度器在<code>SM</code>中分发线程束，以及与内存相关的单元，例如<code>load/store unit</code>加载/存储单元（LDST），<code>L1 cache/shared memory</code>L1缓存/共享内存和<code>register file</code>寄存器文件。多个<code>SM</code>组成了一个<code>cluster</code>集群，每个<code>cluster</code>通过<code>interconnect</code>连接到<code>memory hierachy</code>内存层次结构。</p>
<p><code>RT Cores</code>是<code>NVIDIA GPUs</code>中用于光追的专用单元，但<code>NVIDIA</code>并未提供其实现细节。因此，本文中建模了我们自己的光追加速器，称为<code>RT unit</code>，详见5.1节。</p>
<h3 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h3><p>光追通过追踪场景中的光线来模拟全局光照效果，每<code>pixel</code>像素追踪的光线数和图像中的像素数量决定了渲染质量。例如对于一个<code>1024*1024</code>的图像，每个像素四个<code>ray samples per pixel</code>光线样本（SSP），需要追踪超过四百万条光线。一个简单的实现需要进行超过一万亿次相交测试才能渲染像<code>Crytek Sponza</code>这样有242K个三角形的场景。因此，<code>primitives</code>原始物体们通常被组织成<code>Acceleration structure</code>加速结构（AS），详见2.4节。光线遍历<code>AS</code>以优化相交测试。对于实时光追应用，一种高效的硬件实现<code>AS</code>遍历至关重要。</p>
<p>光线在数学上被描述为具有起点，方向和长度的射线，表示为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.491ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 3310.9 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(707.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1707.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(2290.7,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mi" transform="translate(2790.9,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container>。虽然光线们在<code>AS</code>中是逐个遍历的，但是具有相似<code>origins</code>起点（o）和<code>directions</code>方向（d）在<code>AS</code>中走的路径相似。对于这些光线，我们可以记忆遍历过程，并且优化帧中未来的光线。这种记忆化可以使得<code>occlusion rays</code>遮挡光线（如<code>AO</code>和<code>shadow rays</code>）受益，因为一旦找到一个第一个交点，搜索就会终止，就有可能跳过整个遍历过程。</p>
<h3 id="Ambient-Occlusion"><a href="#Ambient-Occlusion" class="headerlink" title="Ambient Occlusion"></a>Ambient Occlusion</h3><p><code>Ambient lighting</code>环境光照是场景中基本水平的照明，通常情况下被艺术家们近似地设定为一个常量值。<code>Ambient occlusion</code>环境光遮挡是一种视觉效果，其中<code>crevices</code>罅隙/凹槽会因为接受较少的环境光而显得暗。在光追过程中，为了计算环境光遮挡，会追踪许多短光线，这些光线从感兴趣的点（通常是场景中的某个表面点）出发，覆盖一个半球面。与其他光线不同，环境遮挡光线不需要最近的交点。在<code>AO</code>计算中，任何<code>ray-object intersection</code>都意味着该点的一些环境光被遮挡了。与物体相交的光线比例代表了被遮挡的环境光的数量。</p>
<p>这种全局环境光遮挡无法在基于光栅化的图形学中准确实现，因为它需要全局信息。相反，<code>screen-space AO</code>屏幕空间环境光遮挡在基于光栅化的图形学中可用，但因为采样在物体后面或者在屏幕之外等基本问题会导致结果较差。在光追中，全局<code>AO</code>的计算成本高，因为需要计算大量光线才能达到高质量的结果。</p>
<h3 id="Ray-Traversal-Algorithm"><a href="#Ray-Traversal-Algorithm" class="headerlink" title="Ray Traversal Algorithm"></a>Ray Traversal Algorithm</h3><p><img src="Algo1.png" alt=""></p>
<p><code>AS</code>可以减少寻找交点所需的<code>ray-primitive test</code>次数，<code>Bounding Volume Hierarchy</code>包围体层次结构（BVH）是当前光追使用的标准<code>AS</code>。<code>BVM</code>树通过将<code>primitives</code>包含在叶子节点中，并递归地用较大的<code>axis-aligned bounding boxes</code>轴对齐包围盒（AABBs）包围低层次的<code>AABBs</code>。如果一条光线没有与某个非叶子节点相交，那它也不会与这个非叶子节点的子节点相交。这种属性将焦点测试的时间复杂度从线性降低到对数的，使得<code>BVH</code>对实时光追的性能至关重要。</p>
<p><code>BVH</code>遍历算法在软件中的实现是一个<code>while-while</code>循环，在<code>Algorithm 1</code>中描述了其用于遮挡光线的情况。外层<code>while</code>循环迭代直到光线完成遍历。内层<code>while</code>对<code>BVH</code>进行<code>depth-first traversal</code>深度优先遍历。深度优先遍历通常需要使用每个线程的<code>traversal stack</code>遍历栈（tStack），或者针对二叉树可能使用<code>bit trail</code>。如果第一个内层<code>while</code>达到叶子节点，那么第二个内部<code>while</code>循环将测试光线与<code>primitives</code>的相交。遍历将继续，知道所有的光线与<code>primitives</code>的相交点都被识别，或者对于遮挡光线而言，只需要找到任意相交。如果没有<code>ray-primitive intersection</code>出现，我们认为光线与场景没有相交。更多的光追背景知识，推荐去看<a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a>。</p>
<p>为了在遍历过程中提高效率，光线首先访问距离光线起点较近的子节点。然而，由于子节点可能重叠，所以第一个相交点可能并不是最近的相交点（<i>注：例如两个primitive非常接近或者部分重叠时，当光线遍历<code>BVH</code>时，如果子节点的边界体积重叠，光线可能会与其中一个相交，但这不意味着这个节点就是最近的相交点</i>）。因此，每个<code>ray-primitive intersection</code>只是一个候选节点，要确定实际最近的相交点，必须识别出所有的候选点。幸运的是，<code>BVH</code>树可以使用平衡节点实现，并且具有可预测的内存使用情况。出于这个原因，我们选择使用<code>BVH</code>树，并且它在现实中被广泛应用，正如<code>OptiX</code>所见。</p>
<p><code>NVIDIA RT Core</code>密切遵循<code>while-while</code>算法。它具备一个<code>traversal unit</code>遍历单元（包含<code>Box intersection Evaluators</code>包围盒相交评估器）和一个<code>intersection unit</code>相交单元（包含<code>Triangle intersection Evaluators</code>原始物体相交评估器）。<code>RT Core</code>首先从<code>SM</code>进行光线查询并触发遍历过程。<code>RT Core</code>从内存提取并解码<code>BVH</code>节点，并反复执行适当的相交测试，直到找到最近的相交点或者确认光线未与任何物体相交。然后将结果返回给<code>SM</code>进行后续处理和着色。</p>
<h3 id="Accelerating-Ray-Tracing"><a href="#Accelerating-Ray-Tracing" class="headerlink" title="Accelerating Ray Tracing"></a>Accelerating Ray Tracing</h3><h2 id="RAY-INTERSRCTION-PREDICTOR-ALGORITHM"><a href="#RAY-INTERSRCTION-PREDICTOR-ALGORITHM" class="headerlink" title="RAY INTERSRCTION PREDICTOR ALGORITHM"></a>RAY INTERSRCTION PREDICTOR ALGORITHM</h2><h2 id="PROPOSED-ARCHITECTURE"><a href="#PROPOSED-ARCHITECTURE" class="headerlink" title="PROPOSED ARCHITECTURE"></a>PROPOSED ARCHITECTURE</h2><h3 id="Predictor-Table-Architecture"><a href="#Predictor-Table-Architecture" class="headerlink" title="Predictor Table Architecture"></a>Predictor Table Architecture</h3><h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><h3 id="Go-Up-Level"><a href="#Go-Up-Level" class="headerlink" title="Go Up Level"></a>Go Up Level</h3><h3 id="Warp-Repacking"><a href="#Warp-Repacking" class="headerlink" title="Warp Repacking"></a>Warp Repacking</h3><h3 id="Hardware-Implementation"><a href="#Hardware-Implementation" class="headerlink" title="Hardware Implementation"></a>Hardware Implementation</h3><h2 id="METHODOLOGY"><a href="#METHODOLOGY" class="headerlink" title="METHODOLOGY"></a>METHODOLOGY</h2><h3 id="Ray-Tracing-Unit"><a href="#Ray-Tracing-Unit" class="headerlink" title="Ray Tracing Unit"></a>Ray Tracing Unit</h3><h3 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h3><h2 id="RESULTS"><a href="#RESULTS" class="headerlink" title="RESULTS"></a>RESULTS</h2><h3 id="Predictor-Table-Configuration"><a href="#Predictor-Table-Configuration" class="headerlink" title="Predictor Table Configuration"></a>Predictor Table Configuration</h3><h3 id="Other-Predictor-Configurations"><a href="#Other-Predictor-Configurations" class="headerlink" title="Other Predictor Configurations"></a>Other Predictor Configurations</h3><h3 id="Limit-Study"><a href="#Limit-Study" class="headerlink" title="Limit Study"></a>Limit Study</h3><h3 id="Other-Applications"><a href="#Other-Applications" class="headerlink" title="Other Applications"></a>Other Applications</h3><h2 id="RELATED-WORKS"><a href="#RELATED-WORKS" class="headerlink" title="RELATED WORKS"></a>RELATED WORKS</h2><h2 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h2><h2 id="QUESTIONS"><a href="#QUESTIONS" class="headerlink" title="QUESTIONS"></a>QUESTIONS</h2><h2 id="REFERENCES"><a href="#REFERENCES" class="headerlink" title="REFERENCES"></a>REFERENCES</h2><ul>
<li><a target="_blank" rel="noopener" href="https://people.ece.ubc.ca/~aamodt/publications/papers/liu.micro2021.pdf">Intersection Prediction for Accelerated GPU Ray Tracing</a></li>
<li><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a></li>
</ul>
</div><div class="tags"><a href="/tags/#Graphics"><i class="fa fa-tag">Graphics</i></a><a href="/tags/#Architecture"><i class="fa fa-tag">Architecture</i></a></div><div class="post-nav"><a class="pre" href="/2023/07/25/Ray-Tracing-in-One-Weekend-2/">Ray Tracing in One Weekend - 2</a><a class="next" href="/2023/07/21/Paper-Reading-0/">Paper Reading 0 - How to read research papers?</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Course/">Course</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp/">Cpp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reading/">Reading</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/07/25/Ray-Tracing-in-One-Weekend-2/">Ray Tracing in One Weekend - 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/24/Paper-Reading-1/">Paper Reading 1 - Intersection Prediction for Accelerated GPU Ray Tracing</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/21/Paper-Reading-0/">Paper Reading 0 - How to read research papers?</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/19/Ray-Tracing-in-One-Weekend-1/">Ray Tracing in One Weekend - 1</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/17/Introduction-of-Interpreter/">Introduction of Interpreter</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/16/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/12/Linear-List-Array/">Linear List - Array</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/05/Cpp-Three-core-components/">Cpp Three core components</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/27/Argumentative-Essays/">Argumentative Essays</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/25/Config-for-anaconda/">Config for anaconda</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html#%E5%8A%9F%E8%83%BD%E9%85%8D%E7%BD%AE" title="Maupassant Config" target="_blank">Maupassant Config</a><ul></ul><a href="https://hexo.io/docs/configuration.html" title="Hexo Docs" target="_blank">Hexo Docs</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Quanzw's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>